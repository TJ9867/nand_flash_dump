;
; Copyright (c) 2024 hexstd
;
; SPDX-License-Identifier: BSD-3-Clause
;

; out: (OSR) -> dst
; in : src -> (ISR)
; push: (ISR) -> RX fifo
; pull: TX fifo -> (OSR)



; clock speed
; 5ns is generally the smallest time difference required in the NAND spec for read
; The pico runs at 133MHz by default, so a period of 7.52 ns
; This means we can get away with no clock division, provided we delay at appropriate points

; to use this in parallel with other SM's (say a write-page .pio program), probably
; need to use the locking/unlocking mechanisms

; i/o pins should be the 8 NAND data pins
; then the 9th is the ready signal

; use  SHIFCTRL_PULL_THRESH to specify autopull threshold

; make sure CE is set before this guy
.program nand
.sideset 4 ; SET: CLE | WE | ALE | RE  ; use set pins for control, out/in pins for data
; I/O: I/O 0...7 | RDY


.wrap_target
    ; CMD 0
    set pins, 0x0B;  | 1 | 1 | 0 | 1 |
    mov osr, ~null
    out pindirs, 8

    set pins, 0x16  ; set i/o 0..7 to output, sideset: 1 | 0 | 1 | 1 | 0 ; 0ns;
    mov pins, 0x0000
    set pins, 0x12; 1 | 0 | 0 | 1 | 0 ; 7.5 ns
    set pins, 0x16 ; WE UP ; 22.5ns


    ; Use 0 for column, address, this interface is page-based
    set pins, 0x0E;          0 | 1 | 1 | 1 | 0
    set pins, 0x0A ; 0 | 1 | 0 | 1 | 0 - Toggle WE
    set pins, 0x0E
    out pins, 0x0 side 0x0A
    set pins, 0x0E
    out pins, 0x0 side 0x0A

    ; Read page address from OSR (17 bits)
    set pins, 0x0E;          0 | 1 | 1 | 1 | 0
    out pins 8 side 0x0A ; 0 | 1 | 0 | 1 | 0 - Toggle WE
    set pins, 0x0E
    out pins, 8 side 0x0A
    set pins, 0x0E
    out pins, 1 side 0x0A

    nop side 0x0E; TODO is this needed?

    ; CMD 30
    set pins, 0x16 ; TODO is this needed?
    mov pins, 0x0030
    set pins, 0x16; 1 | 0 | 0 | 1 | 0 ; CMD 0 ; 7.5 ns
    set pins, 0x12 ; 1 | 0 | 0 | 1 | 0 | ; 15ns
    set pins, 0x16 ; WE UP ; 22.5ns


    ; wait for RDY TODO

    out x, 15
    set pins, 0x6 [1]; 1-4096 length from OSR ; 0 | 0 | 1 | 1 | 0;
                      ; ^^ must be enforced in calling code, not this program
    mov osr, null
    out pindirs, 8
    ; need delay of 100ns - 15ns
    wait 1 gpio 1 [3]; // wait for RDY (input mapping #1)

read_loop:
    set pins, 0x4 [3] ; 0 | 0 | 1 | 0 | 0 ; set RE
    in pins, 8;  autopush saving us here
    set pins, 0x6 ; 0 | 0 | 1 | 1 | 0 ; unset RE
    jmp x-- read_loop;
    ; somehow flag to let cpu know we've finished this loop at some point
.wrap



% c-sdk {
#include "nand_pio.h"

static inline void nand_rx_program_init(PIO pio, uint sm, uint offset, nand_pins_t* pins) {
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 1, false);
    pio_gpio_init(pio, pin);
    gpio_pull_up(pin);

    pio_sm_config c = nand_rx_program_get_default_config(offset);
    sm_config_set_in_pins(&c, pin); // for WAIT, IN
    sm_config_set_jmp_pin(&c, pin); // for JMP
    // Shift to right, autopush disabled
    sm_config_set_in_shift(&c, true, false, 32);
    // Deeper FIFO as we're not doing any TX
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);
    // SM transmits 1 bit per 8 execution cycles.
    float div = (float)clock_get_hz(clk_sys) / (8 * baud);
    sm_config_set_clkdiv(&c, div);

    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}

%}
